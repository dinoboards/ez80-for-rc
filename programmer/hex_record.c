#include "hex_record.h"
#include "ifl.h"
#include <stdbool.h>
#include <stdio.h>

#define REC_TYPE_DATA              0x00
#define REC_TYPE_EOF               0x01
#define REC_TYPE_EXT_SEG_ADDR      0x02
#define REC_TYPE_START_SEG_ADDR    0x03
#define REC_TYPE_EXT_LINEAR_ADDR   0x04
#define REC_TYPE_START_LINEAR_ADDR 0x05

extern const uint8_t ez80_rc_firmware[];
static uint16_t      ez80_rc_firmware_index;

static uint8_t  length;
static uint8_t  check_sum;
static uint8_t  offset_high, offset_low;
static uint32_t base_addr = 0;
static bool     internal;

static bool eof = false;

static uint8_t getCh(void) {
  if (eof)
    return 26;

  if (internal) {
    printf("\r\nException: getCh called when using internal firmware image\r\n");
    return 0;
  }

  uint8_t ch = getchar();
  if (ch == 26)
    eof = true;

  return ch;
}

static uint8_t parse_byte(const uint8_t *ch) {
  static uint8_t high_nibble, low_nibble;

  high_nibble = ch[0] - '0';
  if (high_nibble > 9)
    high_nibble -= 7;

  low_nibble = ch[1] - '0';
  if (low_nibble > 9)
    low_nibble -= 7;

  return ((high_nibble << 4) | low_nibble);
}

static uint8_t get_next_byte() {
  if (internal)
    return ez80_rc_firmware[ez80_rc_firmware_index++];

  static uint8_t ch[2];

  ch[0] = getCh();
  ch[1] = getCh();

  return parse_byte(ch);
}

static void find_record_start() {
  if (internal)
    return;
  static uint8_t data;
  do {
    data = getCh();
  } while (data != ':');
}

static uint8_t process_hex_record_header() {
  static uint8_t record_type;

  if (internal) {
    length      = ez80_rc_firmware[ez80_rc_firmware_index++];
    offset_high = ez80_rc_firmware[ez80_rc_firmware_index++];
    offset_low  = ez80_rc_firmware[ez80_rc_firmware_index++];
    record_type = ez80_rc_firmware[ez80_rc_firmware_index++];
    check_sum   = length + offset_high + offset_low + record_type;
    return record_type;
  }

  static uint8_t ch[2 * 4];
  find_record_start();

  for (int i = 0; i < 4 * 2; i++) {
    ch[i] = getCh();
  }

  length      = parse_byte(&ch[0]);
  offset_high = parse_byte(&ch[2]);
  offset_low  = parse_byte(&ch[4]);
  record_type = parse_byte(&ch[6]);
  check_sum   = length + offset_high + offset_low + record_type;

  return record_type;
}

static int8_t process_hex_record_eof() {
  check_sum += get_next_byte();
  return (check_sum != 0) ? ZFL_ERR_FAILURE : ZFL_ERR_SUCCESS;
}

static void process_hex_record_ext_seg_addr() {
  printf("\r\nUnexpected 16-bit Extended Segment Address Record\r\n");
  base_addr = (get_next_byte() << 12) + (get_next_byte() << 4);
}

static void process_hex_record_start_seg_addr() {
  get_next_byte();
  get_next_byte();
  printf("\r\nIgnore start Segment Address Record\r\n");
}

static int8_t process_hex_record_ext_linear_addr() {
  if (get_next_byte() == 0) {
    uint8_t base = get_next_byte();
    check_sum += base;
    check_sum += get_next_byte();
    if (check_sum) {
      printf("\r\ncheck_sum error %X\r\n", check_sum);
      return ZFL_ERR_VERIFY;
    }

    base_addr = ((uint32_t)base << 16);
    return ZFL_ERR_SUCCESS;
  }

  printf("\r\nInvalid Address\r\n");
  return ZFL_ERR_ADDRESS;
}

static void process_hex_record_start_linear_addr() {
  get_next_byte();
  get_next_byte();
  get_next_byte();
  get_next_byte();
  printf("\r\nIgnore start Linear Address Record\r\n");
}

int8_t extract_buffer(uint8_t *pBuffer, uint16_t length) {
  static uint8_t  buffer_ch[64 * 2 + 10];
  uint16_t        buffer_index = 0;
  static uint8_t *pCh;
  static uint8_t  data;

  if (internal) {
    for (int i = 0; i < length + 1; i++)
      pBuffer[i] = ez80_rc_firmware[ez80_rc_firmware_index++];

    return ZFL_ERR_SUCCESS;
  }

  for (int i = 0; i < 2 * (length + 1); i++)
    buffer_ch[i] = getCh();

  pCh = buffer_ch;

  while (buffer_index < length) {
    data = (*pBuffer = parse_byte(pCh));
    pBuffer++;
    buffer_index++;
    pCh += 2;
    check_sum += data;
  }

  data = parse_byte(pCh);
  check_sum += data;
  if (check_sum) {
    printf("\r\ncheck_sum error: %X - %X\r\n", check_sum, data);
    return ZFL_ERR_VERIFY;
  }

  return ZFL_ERR_SUCCESS;
}

int8_t process_hex_record_data(const char *prefix, emit_func_t emit) {
  static int8_t   status = ZFL_ERR_SUCCESS;
  static uint8_t  buffer[64 + 10];
  static uint32_t offset;

  offset = base_addr | (offset_high << 8) | offset_low;

  if (length > 64) {
    printf("\r\nData record too long: %X (%lX...%lx)\r\n", length, offset, offset + length);
    return ZFL_ERR_FAILURE;
  }

  status = extract_buffer(buffer, length);
  if (status != ZFL_ERR_SUCCESS)
    return status;

  if (offset > IFL_BIOS_END) {
    // The hex files generated by ZDS also include BSS zeroed data
    // not something that can be flash, nor do we want to reset on-chip state
    // so we just ignore it
    return ZFL_ERR_SUCCESS;
  }

  status = IFL_IsAddrValid(offset, length);
  if (status != ZFL_ERR_SUCCESS) {
    printf("\r\nIFL_IsAddrValid error: %X (%lX...%lx)\r\n", status, offset, offset + length);
    return status;
  }

  printf("\r%s %06lX...%06lX", prefix, offset, offset + length);

  status = emit(offset, buffer, length);
  if (status != ZFL_ERR_SUCCESS) {
    printf("\r\nemit error: %X", status);
    return status;
  }

  return status;
}

/*
 * Process the Intel Hex records
 *
 * @param internal - true to flash the embedded firmware, false expect a intel hex file to be streamed over stdin
 * @param emit - function to write data to the flash
 */
int8_t process_hex_records(const bool _internal, const char *prefix, const emit_func_t emit) {
  static int8_t  status = ZFL_ERR_SUCCESS;
  static uint8_t record_type;

  eof                    = false;
  length                 = 0;
  check_sum              = 0;
  offset_high            = 0;
  offset_low             = 0;
  base_addr              = 0;
  internal               = _internal;
  ez80_rc_firmware_index = 0;

  while (!eof) {
    record_type = process_hex_record_header();

    switch (record_type) {
    case (REC_TYPE_DATA): {
      status = process_hex_record_data(prefix, emit);
      if (status)
        return status;

      break;
    }

    case (REC_TYPE_EOF): {
      return process_hex_record_eof();
    }

    case (REC_TYPE_EXT_SEG_ADDR): {
      process_hex_record_ext_seg_addr();
      break;
    }

    case (REC_TYPE_START_SEG_ADDR): {
      process_hex_record_start_seg_addr();
      break;
    }

    case (REC_TYPE_EXT_LINEAR_ADDR): {
      status = process_hex_record_ext_linear_addr();
      if (status)
        return status;
      break;
    }

    case (REC_TYPE_START_LINEAR_ADDR): {
      process_hex_record_start_linear_addr();
      break;
    }

    default: {
      printf("\r\nUnknown Record Type: %X\r\n", record_type);
      return ZFL_ERR_FAILURE;
    }
    }
  }

  return status;
}
