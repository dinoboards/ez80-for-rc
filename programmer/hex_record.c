#include "hex_record.h"
#include "ifl.h"
#include <stdbool.h>
#include <stdio.h>

#define REC_TYPE_DATA              0x00
#define REC_TYPE_EOF               0x01
#define REC_TYPE_EXT_SEG_ADDR      0x02
#define REC_TYPE_START_SEG_ADDR    0x03
#define REC_TYPE_EXT_LINEAR_ADDR   0x04
#define REC_TYPE_START_LINEAR_ADDR 0x05

static uint8_t  length;
static uint8_t  check_sum;
static uint8_t  offset_high, offset_low;
static uint32_t base_addr = 0;

static bool eof = false;

static uint8_t getCh(void) {
  if (eof)
    return 26;

  uint8_t ch = getchar();
  if (ch == 26)
    eof = true;

  return ch;
}

static uint8_t parse_byte(const uint8_t *ch) {
  static uint8_t high_nibble, low_nibble;

  high_nibble = ch[0] - '0';
  if (high_nibble > 9)
    high_nibble -= 7;

  low_nibble = ch[1] - '0';
  if (low_nibble > 9)
    low_nibble -= 7;

  return ((high_nibble << 4) | low_nibble);
}

static uint8_t get_next_byte() {
  static uint8_t ch[2];

  ch[0] = getCh();
  ch[1] = getCh();

  return parse_byte(ch);
}

static void find_record_start() {
  static uint8_t data;
  do {
    data = getCh();
  } while (data != ':');
}

static uint8_t process_hex_record_header() {
  static uint8_t ch[2 * 4];
  static uint8_t record_type;

  find_record_start();

  for (int i = 0; i < 4 * 2; i++) {
    ch[i] = getCh();
  }

  length      = parse_byte(&ch[0]);
  offset_high = parse_byte(&ch[2]);
  offset_low  = parse_byte(&ch[4]);
  record_type = parse_byte(&ch[6]);
  check_sum   = length + offset_high + offset_low + record_type;

  return record_type;
}

static int8_t process_hex_record_eof() {
  check_sum += get_next_byte();
  return (check_sum != 0) ? ZFL_ERR_FAILURE : ZFL_ERR_SUCCESS;
}

static void process_hex_record_ext_seg_addr() {
  printf("\r\nUnexpected 16-bit Extended Segment Address Record\r\n");
  base_addr = (get_next_byte() << 12) + (get_next_byte() << 4);
}

static void process_hex_record_start_seg_addr() {
  get_next_byte();
  get_next_byte();
  printf("\r\nIgnore start Segment Address Record\r\n");
}

static int8_t process_hex_record_ext_linear_addr() {
  if (get_next_byte() == 0) {
    base_addr = ((uint32_t)get_next_byte() << 16);
    return ZFL_ERR_SUCCESS;
  }

  printf("\r\nInvalid Address\r\n");
  return ZFL_ERR_ADDRESS;
}

static void process_hex_record_start_linear_addr() {
  get_next_byte();
  get_next_byte();
  get_next_byte();
  get_next_byte();
  printf("\r\nIgnore start Linear Address Record\r\n");
}

int8_t process_hex_record_data(emit_func_t emit) {
  static int8_t   status = ZFL_ERR_SUCCESS;
  static uint8_t *pCh;
  static uint8_t *pBuffer;
  static uint16_t buffer_index;
  static uint8_t  buffer_ch[64 * 2 + 10];
  static uint8_t  buffer[64 + 10];
  static uint32_t offset;
  static uint8_t  data;

  offset = base_addr | (offset_high << 8) | offset_low;

  if (offset > IFL_BIOS_END) {
    // The hex files generated by ZDS also include BSS zeroed data
    // not something that can be flash, nor do we want to reset on-chip state
    // so we just ignore it
    return ZFL_ERR_SUCCESS;
  }

  status = IFL_IsAddrValid(offset, length);
  if (status != ZFL_ERR_SUCCESS) {
    printf("\r\nIFL_IsAddrValid error: %X (%lX...%lx)\r\n", status, offset, offset + length);
    return status;
  }

  if (length > 64) {
    printf("\r\nData record too long: %X (%lX...%lx)\r\n", length, offset, offset + length);
    return ZFL_ERR_FAILURE;
  }

  buffer_index = 0;

  printf("\rWriting to: %lX...%lx", offset, offset + length);

  for (int i = 0; i < 2 * (length + 1); i++) {
    buffer_ch[i] = getCh();
  }

  pCh     = buffer_ch;
  pBuffer = buffer;

  while (buffer_index < length) {
    data = (*pBuffer = parse_byte(pCh));
    pBuffer++;
    buffer_index++;
    pCh += 2;
    check_sum += data;
  }

  data = parse_byte(pCh);
  check_sum += data;
  if (check_sum) {
    printf("\r\n<check_sum error> %X - %X\r\n", check_sum, data);
    return ZFL_ERR_VERIFY;
  }

  status = emit(offset, buffer, length);
  if (status != ZFL_ERR_SUCCESS) {
    printf("\r\nemit error: %X", status);
    return status;
  }

  return status;
}

int8_t process_hex_records(emit_func_t emit) {
  static int8_t  status = ZFL_ERR_SUCCESS;
  static uint8_t record_type;

  eof         = false;
  length      = 0;
  check_sum   = 0;
  offset_high = 0;
  offset_low  = 0;
  base_addr   = 0;

  while (!eof) {
    record_type = process_hex_record_header();

    switch (record_type) {
    case (REC_TYPE_DATA): {
      status = process_hex_record_data(emit);
      if (status)
        return status;

      break;
    }

    case (REC_TYPE_EOF): {
      return process_hex_record_eof();
    }

    case (REC_TYPE_EXT_SEG_ADDR): {
      process_hex_record_ext_seg_addr();
      break;
    }

    case (REC_TYPE_START_SEG_ADDR): {
      process_hex_record_start_seg_addr();
      break;
    }

    case (REC_TYPE_EXT_LINEAR_ADDR): {
      status = process_hex_record_ext_linear_addr();
      if (status)
        return status;
      break;
    }

    case (REC_TYPE_START_LINEAR_ADDR): {
      process_hex_record_start_linear_addr();
      break;
    }

    default: {
      printf("\r\nUnknown Record record_type: %X\r\n", record_type);
      return ZFL_ERR_FAILURE;
    }
    }
  }

  return status;
}
